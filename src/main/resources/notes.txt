
@Query("select s from Student s join s.courses ")
List<Student> findStudentsEnrolledInAtleastACourse();

List<Student> s = studentRepository.findStudentsEnrolledInAtleastACourse();
for(Student s1: s){
System.out.println(s1.getId());
}

a student is enrolled in multiple courses, but only distinct student id are fetched when i execute. why ?

That is a fantastic observation, and it highlights a very subtle but important behavior of how Hibernate processes the results of a JPQL query, especially when compared to how raw SQL works.

You are correct that the raw SQL generated by your query will produce duplicate rows for students enrolled in multiple courses. However, the final List<Student> you get back in your Java code is different.

Let's break down the reason.

The Query and The SQL

Your JPQL Query:

Generated jpql
@Query("select s from Student s join s.courses")
List<Student> findStudentsEnrolledInAtleastACourse();


select s: This is key. You are telling JPA you want to retrieve Student entities.

join s.courses: This is an INNER JOIN. It correctly filters out any students who are not enrolled in at least one course.

Generated SQL (simplified):

Generated sql
SELECT s.id, s.first_name, s.email, ...
FROM
    student s
INNER JOIN
    course_students cs ON s.id = cs.students_id
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
SQL
IGNORE_WHEN_COPYING_END

(Note: It might also join to the course table, but the join to course_students is the part that creates the duplicates).

If Alice (ID=1) is in 3 courses, the raw result set from the database will look like this:

Generated code
id | first_name | email
-----------------------------------
1  | Alice      | alice@example.com
1  | Alice      | alice@example.com
1  | Alice      | alice@example.com
2  | Bob        | bob@example.com
...
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

The database correctly returns 3 rows for Alice.

The Magic: Hibernate's Result Processing & the First-Level Cache

So why does your List<Student> in Java not contain three alice_instance objects?

The reason is how Hibernate (your JPA provider) processes this result set to build your Java objects. It does this in conjunction with the First-Level Cache (the Session Cache) and its Identity Map.

Here's the step-by-step process inside Hibernate:

Process Row 1:

Hibernate reads the first row: (id=1, name='Alice', ...)

It checks its L1 Cache: "Do I have a Student object with ID=1 managed in this session?" No.

It creates a new Student object (alice_instance_1) and populates it.

It places this new object into the L1 Cache: [Key: (Student.class, 1), Value: alice_instance_1]

It adds alice_instance_1 to the result list that it will eventually return to you.

Process Row 2:

Hibernate reads the second row: (id=1, name='Alice', ...)

It checks its L1 Cache: "Do I have a Student object with ID=1 managed in this session?" Yes, I do! It's alice_instance_1.

Crucially, Hibernate discards the data from this row because it already has an object representing this entity. It does not create a new Student object.

It then decides what to add to the result list. And here is the subtle behavior: Because the root of your SELECT clause is an entity (SELECT s), Hibernate's default behavior is to not add the same object instance to the list multiple times. It understands you asked for a list of entities, and it already has that entity represented.

Process Row 3:

The exact same thing happens as in Step 2. Hibernate finds the existing alice_instance_1 in its cache and does nothing further with the result list.

Process Row 4 (Bob):

Hibernate reads the next row for a new student, say (id=2, name='Bob', ...)

It checks its L1 Cache for (Student.class, 2). It doesn't find it.

It creates a new Student object (bob_instance_1), puts it in the cache, and adds it to the result list.

Conclusion and Key Takeaway

Even though the underlying SQL query produces duplicate rows for the parent entity (Student), Hibernate's result-set processing logic implicitly filters these duplicates when the root of the SELECT clause is an entity.

It does this because the First-Level Cache guarantees object identity. Within a single session, there can only ever be one Java object instance for a given database row (e.g., one instance for Student with ID=1). When it encounters subsequent rows for the same entity, it recognizes them as duplicates and doesn't add another reference to the final list.

This is why your code correctly prints distinct student IDs.

What if you did want the duplicates?

If you selected individual fields instead of the whole entity, you would see the duplicates.

Generated java
@Query("select s.id, s.firstName from Student s join s.courses")
List<Object[]> findStudentData(); // Returns a List of Object arrays
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Java
IGNORE_WHEN_COPYING_END

This query would return a list where the array [1, "Alice"] appears three times. This is because you are no longer asking for managed entities, but for raw data, and Hibernate will return exactly what the database gives it.




how does cache work in this case:
@Query("select s.id, s.firstName from Student s join s.courses")
List<Object[]> findStudentData();


That's an excellent question that really gets to the heart of what the cache is and what it is not.

In this specific case, for this specific query, the First-Level Cache plays almost no role in constructing the final result list.

Let's break down why.

The Type of Query: A "Projection"

Your query is:
@Query("select s.id, s.firstName from Student s join s.courses")

This is known as a projection query. You are not asking JPA to give you back a managed Student entity object. Instead, you are projecting the results into a different format—in this case, a List<Object[]>. You are asking for raw data, not managed objects.

How Hibernate Processes This Query

Here’s the step-by-step of what happens, and you'll see why the cache isn't used in the same way.

SQL Generation: Hibernate generates the same underlying SQL as before, joining student and course_students.

Generated sql
SELECT s.id, s.first_name
FROM
    student s
INNER JOIN
    course_students cs ON s.id = cs.students_id


Database Result Set: The database returns a raw, tabular result. If Alice (ID=1) is in 3 courses and Bob (ID=2) is in 2 courses, the result set looks like this:

Generated code
id | first_name
-----------------
1  | Alice
1  | Alice
1  | Alice
2  | Bob
2  | Bob
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Hibernate's Result Processing (The Key Difference):
Hibernate now iterates through this result set. But because you asked for an Object[], its job is much simpler and it does not engage the First-Level Cache for object identity management.

Process Row 1:

Hibernate reads (1, "Alice").

It creates a new array: new Object[]{1L, "Alice"}.

It adds this array to the result List.

It does NOT create a Student entity. It does NOT check or update the L1 Cache.

Process Row 2:

Hibernate reads (1, "Alice").

It creates a new, separate array: new Object[]{1L, "Alice"}.

It adds this new array to the result List.

Process Row 3:

Hibernate reads (1, "Alice").

It creates yet another new, separate array: new Object[]{1L, "Alice"}.

It adds this new array to the result List.

And so on for Bob...

The Final Result

The List<Object[]> that is returned to your Java code will contain all the duplicate rows that the database returned. It will look like this:

Generated code
[
  [1L, "Alice"],
  [1L, "Alice"],
  [1L, "Alice"],
  [2L, "Bob"],
  [2L, "Bob"]
]
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END
So, Does the Cache Do Anything?

While the cache is not used to build the final List<Object[]>, it might have been used before this query, or it might be updated if you were also selecting a full entity.

Let's consider a slightly different query:
@Query("select s, c.courseName from Student s join s.courses c")

In this case, you are selecting a managed entity (s) and a projected scalar value (c.courseName). Here, Hibernate would:

Process the results and use the L1 cache to ensure only one instance of the Student object for Alice exists.

The final result would be a List<Object[]> where the first element of each array is a Student object and the second is a String.

The list would still contain duplicate rows, but the Student object reference for Alice in each of those rows would be the exact same Java object instance, thanks to the L1 cache.

Generated code
[
  [alice_instance, "CS-101"],
  [alice_instance, "PHY-201"],
  [alice_instance, "MATH-301"]
]
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END
Conclusion

When your JPQL query projects only scalar values or non-entity types (like s.id, s.firstName, count(s), or DTOs), the First-Level Cache's identity management feature is not used to de-duplicate the results.

The cache's primary role is to manage the lifecycle and guarantee the identity of managed entity objects. If you don't ask for managed entities in your SELECT clause, Hibernate simply acts as a thin wrapper over the raw database result set, giving you exactly what the database returned, duplicates and all.